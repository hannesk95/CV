function [mask] = segmentation(left,right)
  N = size(left,3) / 3 - 1;
  
  %% Segmentation of the image
  I = rgb2gray(left(:,:,1:3));
  labels = watershed_segmentation(left, right);
  Lrgb = label2rgb(labels,'jet','w','shuffle');
  figure
  imshow(Lrgb)
  
  
  %% Determine region of interest
  roi = find_roi(left, right);
  
  %% Extract movements
  
  % Stores the correspondence pairs between frame 1 and the consecutive
  % frames of the left channel.
  correspondences = cell(1, N);
  features = harris_detector(I,'tile_size',50,'segment_length',9,'k',0.08,'min_dist',10,'N',10,'do_plot',false);
  % Find correspondences
  for i = 1:N
      I_n = rgb2gray(left(:,:,(1:3) + i*3));
      features_n = harris_detector(I_n,'tile_size',50,'segment_length',9,'k',0.08,'min_dist',10,'N',10,'do_plot',false);
      corr = point_correspondence(I,I_n,features,features_n,'window_length',15,'min_corr', 0.9,'do_plot',true);  
      % Remove correspondences outside of 
      correspondences(i) = { corr };
  end  
 
  % Variable movements stores the squared magnitude of pixel movements  
  % in tiles between the first and following frames.
  % e.g. movements(1, 3, 1) holds the sqaured magnitude of the
  % (interpolated) movement of tile (1, 3) between frame 1 and 2.
  tile_size = [50, 50];
  kx = size(I, 2) / tile_size(1);
  ky = size(I, 1) / tile_size(2);
  rx = ceil(kx) * tile_size(1) - size(I, 2) + 1;
  ry = ceil(ky) * tile_size(2) - size(I, 1) + 1;
  t1 = (1 - rx / 2) : tile_size(1) : (size(I, 2) + rx / 2 - tile_size(1));
  t2 = (1 - ry / 2) : tile_size(2) : (size(I, 1) + ry / 2 - tile_size(2)); 
  movements = zeros(length(t2), length(t1), N);
  for i = 1:N
      corr = cell2mat(correspondences(i));
      x1 = corr(1:2, :);
      x2 = corr(3:4, :);
      v = x1 - x2;
      v = sum(v .* v);
      F = scatteredInterpolant(x1(1,:)', x1(2,:)', v');
      [q1, q2] = meshgrid(t1, t2);
      m = F(q1, q2);
      m = m .* double(m > 0);
      movements(:, :, i) = m;
  end
  
  
  % Variable segment_movement stores movement informations about each
  % segment which was generated by the watershed segmentation.
  % e.g. segment_movement(3,1) holds a list of all squared movement
  % magnitudes between image 1 and 2 laying in segment 3.
  N_segments = max(labels(:));
  segment_movement = cell(N_segments, N);
  segment_movement(:) = { zeros(length(t2) * length(t1), 1) };
  movement_counter = zeros(N_segments, N);
  for i = 1:N
    image_movement = movements(:, :, i);
    for j = 1:numel(image_movement)
        % extract tile indicies
        [tn, tm] = ind2sub(size(image_movement), j);    
        % Store squared magnitude of movement
        m2 = image_movement(tn, tm);
        % calculate tile center position
        tx = t1(tm);
        ty = t2(tn);
        % calculate tile edge positions
        left = ceil(tx);
        right = left + tile_size(1) - 1;
        top = ceil(ty);
        bottom = top + tile_size(2) - 1;
        % Limit values
        if left < 1
            left = 1;
        end
        if right > size(I, 2)
            right = size(I, 2);
        end
        if top < 1
            top = 1;
        end
        if bottom > size(I, 1)
            bottom = size(I, 1);
        end
        % Find labels in tile
        tile_labels = labels(top:bottom, left:right);
        tile_labels(tile_labels(:) == 0) = [];
        tile_segments = unique(tile_labels(:));
        for k = 1:length(tile_segments)
            label = tile_segments(k);
            if label ~= 0
                n = movement_counter(label, i);
                n = n + 1;
                movement_counter(label, i) = n;
                m = cell2mat( segment_movement(label, i) );
                m(n) = m2;
                segment_movement(label, i) = { m };
            end
        end
        %winning_segment = mode(tile_labels(:));
        % Store movement information
        %if winning_segment ~= 0
        %    n = movement_counter(winning_segment, i);
        %    n = n + 1;
        %    movement_counter(winning_segment, i) = n;
        %    m = cell2mat( segment_movement(winning_segment, i) );
        %    m(n) = m2;
        %    segment_movement(winning_segment, i) = { m };
        %end
    end
  end
  % Remove empty entries
  for k = 1:numel(movement_counter)
      [s, i] = ind2sub(size(movement_counter), k);
      n = movement_counter(s,i);
      m = cell2mat( segment_movement(s, i) );
      m(n+1 : end) = [];
      segment_movement(s, i) = { m };
  end
  % Variable movement_median stores the median value of the movement
  % magnitudes for each segment.
  % e.g. movement_median(3, 1) holds the median value of the movement
  % magnitudes between frame 1 and frame 2 for segment 3.
  movement_median = zeros(N_segments, N);
  % Variable movement_avg stores the average movement for each segment.
  % e.g. movement_avg(12) holds the average movement of segment 12.
  movement_avg = zeros(N_segments, 1);
  % Variable movement_var stores the variance of movement changes for
  % each segment.
  movement_var = zeros(N_segments, 1);
  for i = 1:N_segments
      m2 = cell2mat(segment_movement(i, :));
      if ~isempty(m2)
          m = sqrt(median(m2));
          movement_median(i, :) = m;
          m = m ./ (1:length(m));
          movement_var(i) = var(m);
          m_avg = mean(m);
          movement_avg(i) = m_avg;
      end
  end
  % Variable movement_rel stores the average movement for each 
  % segmentscaled by the segment area.
  movement_rel = zeros(N_segments, 1);
  for i = 1:N_segments
      n = sum(labels(:) == i);
      movement_rel(i) = movement_avg(i) / n;
  end
  
  foreground_labels = find(movement_avg > 2 & movement_avg < 100);
  
  mask = ismember(labels, foreground_labels);
  
  %% Dilate mask
  se = strel('disk',10);
  mask = imdilate(mask,se);
  figure
  imshow(mask)
end
